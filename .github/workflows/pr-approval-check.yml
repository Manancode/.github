name: PR Approval Check

on:
  pull_request_target:
    types: [opened]

jobs:
  check-linked-issue:
    if: startsWith(github.repository, 'asyncapi/')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const botsList = ['asyncapi-bot', 'dependabot[bot]', 'dependabot-preview[bot]', 'allcontributors[bot]', 'github-actions[bot]'];
            const prAuthor = context.payload.pull_request.user.login;
            
            if (botsList.includes(prAuthor)) {
              console.log(`Skipping: ${prAuthor} is a bot`);
              return;
            }

            let permissionLevel = 'none';
            try {
              const { data } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: prAuthor
              });
              permissionLevel = data.permission;
            } catch (error) {
              console.log(`Could not get permission level for ${prAuthor}: ${error.message}`);
            }

            if (['admin', 'write'].includes(permissionLevel)) {
              console.log(`Skipping: ${prAuthor} is a maintainer (${permissionLevel})`);
              return;
            }

            const prNumber = context.payload.pull_request.number;
            const prBody = context.payload.pull_request.body || '';
            
            const issuePattern = /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s*:?\s*#(\d+)/gi;
            const matches = [...prBody.matchAll(issuePattern)];
            const linkedIssues = matches.map(m => parseInt(m[1]));

            if (linkedIssues.length === 0) {
              console.log(`PR #${prNumber} has no linked issues - allowing standalone PR`);
              return;
            }

            for (const issueNumber of linkedIssues) {
              let issue;
              try {
                const { data } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                issue = data;
              } catch (error) {
                console.log(`Could not fetch issue #${issueNumber}: ${error.message}`);
                continue;
              }

              const labels = issue.labels.map(l => l.name);
              const isApproved = labels.includes('approved');
              const needsApproval = labels.includes('needs-approval');
              const isClosed = issue.state === 'closed';

              if (isClosed && !isApproved) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `This PR references issue #${issueNumber} which was closed without approval.\n\nPRs should only address approved issues. Please ensure the related issue is approved before submitting a PR.\n\nThis PR will be closed automatically. If you believe this is a mistake, please reach out to a maintainer.`
                });

                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  state: 'closed'
                });

                console.log(`Closed PR #${prNumber} - linked issue #${issueNumber} was closed without approval`);
                return;
              }

              if (needsApproval) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `This PR references issue #${issueNumber} which has not been approved yet.\n\nPlease wait for a maintainer to approve the issue before submitting a PR. This ensures your effort aligns with project goals.\n\nThis PR will be closed automatically. Once the issue is approved, feel free to reopen this PR or create a new one.`
                });

                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  state: 'closed'
                });

                console.log(`Closed PR #${prNumber} - linked issue #${issueNumber} needs approval`);
                return;
              }
            }

            console.log(`PR #${prNumber} passed approval check`);

