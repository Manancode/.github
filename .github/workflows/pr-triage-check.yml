name: PR Triage Check

on:
  pull_request_target:
    types: [opened, edited, synchronize]

jobs:
  check-pr-triage:
    if: startsWith(github.repository, 'asyncapi/') || github.repository == 'Manancode/.github'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const botsList = ['asyncapi-bot', 'asyncapi-bot-eve', 'dependabot[bot]', 'dependabot-preview[bot]', 'allcontributors[bot]', 'github-actions[bot]'];
            const prAuthor = context.payload.pull_request.user.login;
            
            if (botsList.includes(prAuthor)) {
              console.log(`Skipping: ${prAuthor} is a bot`);
              return;
            }

            let isCodeowner = false;
            try {
              const { data: codeownersFile } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'CODEOWNERS'
              });
              
              const codeownersContent = Buffer.from(codeownersFile.content, 'base64').toString('utf-8');
              const codeownerPattern = /@([\w-]+)/g;
              const codeowners = [...codeownersContent.matchAll(codeownerPattern)].map(m => m[1]);
              
              isCodeowner = codeowners.includes(prAuthor);
            } catch (error) {
              console.log(`Could not read CODEOWNERS: ${error.message}`);
            }

            if (isCodeowner) {
              console.log(`Skipping: ${prAuthor} is a CODEOWNER`);
              return;
            }

            const prNumber = context.payload.pull_request.number;
            // Linked issues: GraphQL closingIssuesReferences (canonical) first, then regex fallback.
            // Official keywords: close, closes, closed, fix, fixes, fixed, resolve, resolves, resolved.
            // Same-repo only. Supports KEYWORD #N and KEYWORD owner/repo#N.
            const { data: prData } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            const prBody = prData.body || '';

            let linkedIssues = [];
            let source = 'none';

            try {
              const gql = `
                query($owner: String!, $repo: String!, $pr: Int!) {
                  repository(owner: $owner, name: $repo) {
                    pullRequest(number: $pr) {
                      closingIssuesReferences(first: 100) {
                        nodes {
                          number
                          repository { name owner { login } }
                        }
                      }
                    }
                  }
                }
              `;
              const { repository } = await github.graphql(gql, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pr: prNumber
              });
              const nodes = repository?.pullRequest?.closingIssuesReferences?.nodes ?? [];
              const sameRepo = nodes.filter(
                n => n?.repository && n.repository.owner?.login === context.repo.owner && n.repository.name === context.repo.repo
              );
              linkedIssues = [...new Set(sameRepo.map(n => n.number).filter(Boolean))];
              if (linkedIssues.length > 0) source = 'graphql';
            } catch (e) {
              console.log(`GraphQL closingIssuesReferences failed: ${e.message}`);
            }

            if (linkedIssues.length === 0) {
              const kw = /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s*:?\s*#(\d+)/gi;
              const ms = [...prBody.matchAll(kw)];
              const same = ms.map(m => parseInt(m[1], 10)).filter(n => !isNaN(n));
              const cross = /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s+([\w.-]+)\/([\w.-]+)#(\d+)/gi;
              const m2 = [...prBody.matchAll(cross)];
              for (const m of m2) {
                if (m[1] === context.repo.owner && m[2] === context.repo.repo) same.push(parseInt(m[3], 10));
              }
              linkedIssues = [...new Set(same)];
              if (linkedIssues.length > 0) source = 'regex';
            }

            console.log(`PR #${prNumber} linked issues: [${linkedIssues.join(', ')}] (${source})`);

            if (linkedIssues.length > 0) {
              if (prData.labels.some(l => l.name === 'no-linked-issue')) {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: 'no-linked-issue'
                });
                console.log(`PR #${prNumber} now has linked issue(s) - removed no-linked-issue label`);
              }
            }

            if (linkedIssues.length === 0) {
              const prLabels = prData.labels.map(l => l.name);

              if (!prLabels.includes('no-linked-issue')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: ['no-linked-issue']
                });
              }

              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });

              const hasComment = comments.some(c => 
                c.user.login === 'github-actions[bot]' && 
                c.body.includes("this PR isn't linked to an approved issue")
              );

              if (!hasComment) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `Thanks for the PR! ðŸŽ‰\n\nIt looks like this PR isn't linked to an approved issue. Please link the issue in the PR description (or create an issue first, get maintainer approval, then link it here).\n\nWe'll wait for you to link it. If it's still not linked after a few weeks, maintainers may close it.\n\nThank you! â¤ï¸`
                });

                console.log(`PR #${prNumber} has no linked issue - added comment and label`);
              }

              return;
            }

            for (const issueNumber of linkedIssues) {
              let issue;
              try {
                const { data } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                issue = data;
              } catch (error) {
                console.log(`Could not fetch issue #${issueNumber}: ${error.message}`);
                continue;
              }

              const labels = issue.labels.map(l => l.name);
              const isTriaged = labels.includes('status/triaged');
              const needsTriage = labels.includes('status/to-be-triaged');
              const isClosed = issue.state === 'closed';

              if (needsTriage && !isClosed) {
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber
                });

                const hasComment = comments.some(c => 
                  c.user.login === 'github-actions[bot]' && 
                  c.body.includes(`issue #${issueNumber}`) &&
                  c.body.includes("hasn't been approved/triaged")
                );

                if (!hasComment) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: `Thanks for the PR! ðŸŽ‰\n\nThis PR is linked to issue #${issueNumber} that hasn't been approved/triaged by maintainers yet.\n\nPlease pause work and wait for maintainer approval on the issue first.\n\nIf it stays open, it may be marked for closure after a grace period.\n\nThank you for your understanding! â¤ï¸`
                  });

                  console.log(`PR #${prNumber} links to untriaged issue #${issueNumber} - added comment`);
                }

                return;
              }

              if (isTriaged) {
                for (const name of ['status/not-needed', 'status/to-be-triaged']) {
                  if (labels.includes(name)) {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      name
                    }).catch(() => {});
                  }
                }
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: ['status/in-progress']
                }).catch(err => console.log('Could not add status/in-progress to issue:', err.message));

                if (prData.labels.some(l => l.name === 'no-linked-issue')) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    name: 'no-linked-issue'
                  }).catch(() => {});
                }
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: ['status/in-review']
                }).catch(err => console.log('Could not add status/in-review to PR:', err.message));

                console.log(`PR #${prNumber} links to triaged issue #${issueNumber} - updated labels`);
              }
            }

            console.log(`PR #${prNumber} passed triage check`);
