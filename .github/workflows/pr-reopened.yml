name: PR Reopened

on:
  pull_request:
    types: [reopened]

jobs:
  cleanup-and-retriage:
    if: startsWith(github.repository, 'asyncapi/') || github.repository == 'Manancode/.github'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const labels = pr.labels.map(l => l.name);

            const toRemove = ['status/not-needed', 'status/done'];
            for (const name of toRemove) {
              if (labels.includes(name)) {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name
                }).catch(() => {});
              }
            }

            console.log(`Cleaned up closure labels from reopened PR #${prNumber}`);

            const prBody = pr.body || '';
            
            const graphqlQuery = `
              query($owner: String!, $repo: String!, $prNumber: Int!) {
                repository(owner: $owner, name: $repo) {
                  pullRequest(number: $prNumber) {
                    closingIssuesReferences(first: 10) {
                      nodes {
                        number
                        repository {
                          owner { login }
                          name
                        }
                      }
                    }
                  }
                }
              }
            `;

            let linkedIssues = [];
            try {
              const result = await github.graphql(graphqlQuery, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                prNumber: prNumber
              });

              const references = result.repository.pullRequest.closingIssuesReferences.nodes || [];
              linkedIssues = references
                .filter(ref => 
                  ref.repository.owner.login === context.repo.owner &&
                  ref.repository.name === context.repo.repo
                )
                .map(ref => ({ number: ref.number, source: 'graphql' }));
            } catch (error) {
              console.log(`GraphQL query failed: ${error.message}`);
            }

            if (linkedIssues.length === 0) {
              const regex = /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s*(?:issue\s+)?:?\s*#\s*(\d+)/gi;
              const matches = [...prBody.matchAll(regex)];
              linkedIssues = [...new Set(matches.map(m => parseInt(m[1], 10)).filter(n => !isNaN(n)))]
                .map(num => ({ number: num, source: 'regex' }));
            }

            console.log(`PR #${prNumber} reopened - found ${linkedIssues.length} linked issues: [${linkedIssues.map(i => `#${i.number} (${i.source})`).join(', ')}]`);

            if (linkedIssues.length === 0) {
              if (!labels.includes('no-linked-issue')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: ['no-linked-issue']
                });

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `This PR has been reopened but does not appear to link to an issue.\n\nPlease link this PR to an issue using keywords like "fixes #123" or "closes #456" in the description.\n\nThank you! ❤️`
                });

                console.log(`Added no-linked-issue label to reopened PR #${prNumber}`);
              }
              return;
            }

            if (labels.includes('no-linked-issue')) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                name: 'no-linked-issue'
              }).catch(() => {});
            }

            for (const linkedIssue of linkedIssues) {
              const issueNumber = linkedIssue.number;
              let issue;
              try {
                const { data } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });
                issue = data;
              } catch (error) {
                console.log(`Could not fetch issue #${issueNumber}: ${error.message}`);
                continue;
              }

              const issueLabels = issue.labels.map(l => l.name);
              const isTriaged = issueLabels.includes('status/triaged');
              const needsTriage = issueLabels.includes('status/to-be-triaged');
              const isClosed = issue.state === 'closed';

              if (needsTriage && !isClosed) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `This PR has been reopened and is linked to issue #${issueNumber} that hasn't been approved/triaged by maintainers yet.\n\nPlease pause work and wait for maintainer approval on the issue first.\n\nThank you for your understanding! ❤️`
                });
                console.log(`PR #${prNumber} links to untriaged issue #${issueNumber} - added comment`);
                return;
              }

              if (isTriaged) {
                const issueToRemove = ['status/not-needed', 'status/to-be-triaged'];
                for (const name of issueToRemove) {
                  if (issueLabels.includes(name)) {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      name
                    }).catch(() => {});
                  }
                }
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: ['status/in-progress']
                }).catch(() => {});

                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: ['status/in-review']
                }).catch(() => {});

                console.log(`Reopened PR #${prNumber} links to triaged issue #${issueNumber} - updated labels`);
              }
            }
